# 全文検索に必要な正規化処理ステップ

## 処理ステップの一覧（番号付き）

1. HTML・Markdown からテキストを抽出する  
2. 不要ブロックとノイズ（広告・フッターなど）を削除する  
3. 余計な空白・改行を正規化する  
4. Unicode 正規化（NFC/NFKC）と文字種統一を行う  
5. 絵文字を完全に除去する  
6. 制御文字・不可視文字を削除する  


***

## 1. HTML・Markdown からテキストを抽出する

HTML や Markdown をそのままトークナイズすると、タグや装飾記号が大量のノイズトークンになるため、最初に構造を解釈して人間可読テキストだけを取り出す。
- HTML: `<p>Hello <b>world</b></p>` → `"Hello world"` のようにタグを落としてプレーンテキスト化する（script/style は原則除外）。
- Markdown: `## 見出し`, `*強調*`, `- 箇条書き` などの記号はパースして、見出し・段落・リスト等のテキストだけを抽出する（構造が必要なら別メタデータに保持）。

## 2. 不要ブロックとノイズ（広告・フッターなど）を削除する

検索クエリと無関係な共通フッターや広告・ナビゲーションは、インデックスするとスコアを汚しやすいので、ブロック単位で除去するのが望ましい。
- 典型例として、サイト共通の「会社情報」「お問い合わせ」「プライバシーポリシー」などは CSS クラスや XPath、Boilerplate 抽出ツールを使って除去する。
- Markdown ベースのブログでも、テンプレート的な署名や SNS ボタン文言などを正規表現やルールで削ると、チャンクの内容が本題に集中する。

## 3. 余計な空白・改行を正規化する

スクレイピング由来のテキストには、連続改行・タブ・インデントなどが大量に紛れ込むため、これを統一してからチャンクを切ると境界が安定する。
- 連続する空白/改行を 1 個に縮約する（例: 3 行以上の空行 → 1 行、連続スペース → 単一スペース）。
- 行末の空白やタブは削除し、改行コードは LF に統一しておくと、後段の分割（段落単位チャンクなど）がシンプルになる。

## 4. Unicode 正規化（NFC/NFKC）と文字種統一を行う

合成文字のゆらぎや全角・半角の違いをここで吸収し、「同じ見た目の文字列は同じバイト列」にそろえる。
- NFC/NFKC: 例えば `e + ◌́` と `é` を同じ正規化形（NFC なら合成済み文字）にそろえることで、インデックスとクエリの一致性が高まる。
- 全角/半角・大小文字: `"ＡＢＣ１２３"` → `"abc123"` のように ASCII へ寄せ、小文字化することで、ユーザーが大文字/全角で打ってもヒットする。日本語カナは全角に統一する。

## 5. 絵文字を完全に除去する

絵文字は多くの一般的な検索タスクでは検索キーにならずノイズとなるため、Unicode で絵文字に分類されるコードポイントをすべて削除する。
- 例: `"最高でした😂 また行きたい！"` → `"最高でした また行きたい！"` のように、文中の絵文字のみを削除し、テキスト部分だけを残す。
- 将来的に絵文字を利用するタスクが出てきた場合に備えたい場合は、ここで削除する前に「絵文字のみを別フィールドに収集する」処理を挟むこともできる。

## 6. 制御文字・不可視文字を削除する

見えないが検索を壊す文字をここで掃除しておくと、チャンク境界やトークン境界が安定する。
- ゼロ幅スペース（U+200B）や NO-BREAK SPACE（U+00A0）、ソフトハイフン（U+00AD）などを表にして、正規表現やテーブルルックアップで除去する。
- C0/C1 制御文字（改行やタブ以外）は、原則削除もしくは空白に正規化することで、「不可視だけど別のトークン扱い」という事故を防ぐ。

# 実装例