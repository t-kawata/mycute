# mycute / cube 知識システム 概要ドキュメント

このドキュメントは、Go言語で実装された単一バイナリサーバー「mycute」と、暗号化された知識キューブ「cube」の仕組みを、初めて読む人やAIシステムでも漏れなく理解できるように解説することを目的とする。
ここに書かれている内容だけを読めば、mycute と cube の基本概念、API群、権限・鍵モデル、およびビジネス的な意味まで一通り把握できる。

***

## 用語と全体像

### mycute とは

Go 言語で実装された **単一バイナリ** のサーバーアプリケーション。  
バイナリ名は `mycute`（「うちのかわいい子」）と呼ぶ。  
`mycute` コマンドを実行すると、REST API サーバーが起動する。  
内部では Kuzu ベースの知識グラフ・RAG的な推論・強化学習的な成長ロジックを扱うが、ここでは抽象概念として扱う。

※ Kuzuデータベースを使用するのは cuber パッケージのみであり、mycute サービス自体のデータは扱わない。
※ mycute サービス自体のデータは MySQL 9.x 以上を使用し、ユーザーアカウント管理等を行う。
※ つまり、Kuzuデータベースは、下記の cube を実現するための「知識固形化装置の重要部品」に過ぎない。

### cube とは

「暗号化された知識の塊」を表す配布単位。  
ファイル拡張子は `.cube` を用いる。  
中身は実質的に Kuzu データベースファイル群をベースとした「メモリキューブ」であり、知識データ本体と利用ポリシー（有効期限や権限）に基づく鍵と組み合わせて運用される。

### usrs（ユーザー）とは

mycute が内部的に持つアカウント概念。  
任意個の usr を作成可能。  
各 usr は、強固な UUID を ID として持つ。  
usr はログインにより JWT を取得し、この JWT を HTTP ヘッダに付与して REST API を利用する。

***

## 認証と権限モデル

### 認証の流れ

usr アカウントが作成される。  
usr は認証操作（ログインなど）を行い、JWT を取得する。  
以後の API 呼び出しは、この JWT を HTTP ヘッダに付与して行う。  
mycute は JWT から usr を特定し、その usr の権限／所有関係に基づいて要求された操作を許可／拒否する。

### 権限のレイヤ

権限は以下のレイヤで構成される。

**usr レベル**  
どの cube にアクセスできるか  
どの操作グループを実行できるか  

**cube レベル**  
その cube 自体の所有者は誰か  
どの usr がどの鍵を通じてアクセスしているか  

**鍵レベル**  
個々の cube に対して、鍵ごとに  
有効期限（expire）  
許可される権限（読み取り専用、書き込み可能、absorb/memify/export の可否など）  
が定義される。

鍵は「cube 専用のライセンス」のように振る舞い、どのユーザーがどの範囲・期間でその知識キューブを利用できるかを規定する。

### 鍵と権限の管理 (Burn-on-use)

本システムにおける「鍵」は、**一度使用すると二度と使えなくなる (Burn-on-use)** ワンタイムライセンスキーのような振る舞いをする。
鍵には一意の `KeyID` が埋め込まれており、`import` や `rekey` で使用された時点でシステムに記録され、無効化される。
これにより、同じ鍵を使い回して期限を延長したりすることはできない。期限や権限を更新したい場合は、必ず新しい鍵の発行を受ける必要がある。

### 詳細な権限 (Granular Permissions) と制限ロジック

権限設定における回数制限（各種 Limit）は以下のロジックで動作する。

- **0**: **無制限 (Unlimited)**。何度でも実行可能。  
- **正の整数 (>0)**: **残り回数 (Remaining)**。実行ごとに減算される。  
- **負の数 (<0)**: **禁止/終了 (Forbidden/Finished)**。実行不可。  
  - 残り回数が `1` の状態で実行すると、`0`（無制限）ではなく `-1`（終了）に遷移する。

制限項目。

- `export_limit`, `rekey_limit`, `genkey_limit`, `absorb_limit`, `memify_limit`, `search_limit`  
- `allow_stats` (bool)  

***

## cubes エンドポイント群の概要

mycute には `cubes` というエンドポイントグループが存在し、cube を中心とした操作を提供する。
主な操作は次の通り。

- `create` (POST)  
- `import` (POST)  
- `export` (GET)  
- `rekey` (PUT)  
- `genkey` (POST)  
- `absorb` (PUT)  
- `memify` (PUT)  
- `search` (GET)  
- `stats` (GET)  
- `delete` (DELETE)

以下、それぞれの意味と振る舞いを詳細に説明する。

***

## create: 新しい cube の生成

### 概要

既存の cube をインポートせず、**まっさらな状態から新しい cube を作成する**。
このとき、cube の所有者（オーナー）は、この `create` を実行した usr になる。
所有者は、初期状態として「Limit = 0 (無制限)」の権限を持つ。

### 特徴

所有者は当該 cube に対して、  
読み取り  
書き込み（知識の追加や再構成）  
memify による自己強化  
export による配布  
を含む **全ての操作** を行う権限を持つ。

所有者は、当該 cube 専用の「鍵」を発行できる。
鍵には、  
有効期限（expire）  
許可される権限（read-only / read-write / memify 許可 / export 許可など）  
が埋め込まれる。
この鍵と cube を組み合わせて `.cube` ファイルとしてエクスポートすれば、  
「どの範囲・どの期間で使えるか」が厳密に制約された配布用メモリキューブ  
を第三者に渡せる。

***

## import: 配布された cube の取り込み

### 概要

外部から渡された `.cube` ファイルと、その cube 専用の鍵を **mycute 内部に取り込む** 操作。
鍵の `KeyID` を消費(Burn)し、鍵に記録された `Permissions` を適用する。
Lineage 情報には、Export時のタイムスタンプも含まれる。

### 振る舞い

usr が `import` エンドポイントを呼び出すと、mycute は:  
アップロードされた `.cube` と鍵を受け取る。  
鍵に記録された  
有効期限（expire）  
権限（読み取りのみ、書き込み可、memify・exportの可否など）  
を検証する。
条件を満たす場合、内部形式の cube として展開し、その usr の環境に「インポートされた cube」として登録する。

インポートされた cube は、**鍵の許可範囲内** で以下の操作が可能になる。

- search による質問・利用  
- 許可されていれば absorb / memify による育成  
- 許可されていれば export による再配布

この時点で、その usr は「cube の所有者」ではなく、「鍵の権限で使える利用者」という立場である点に注意する。

***

## export: cube の再配布

### 概要

mycute 内部に存在する cube を、新たな `.cube` ファイルとしてエクスポートする操作。
新しい UUID を付与し、**Export Record** を作成する。
**ここでは鍵の発行は行わない**。まずは物理ファイルを作成するのみである。
Lineage に現在の `ExportedAt` (ms) を記録する。

### エクスポート可能な対象

- usr 自身が `create` した、**自分が所有者である cube**。  
- 他者が作った cube を `import` し、その後自分の環境で **育てた cube**。

### 重要な制約：親鍵による「上限」

インポートした cube から派生した cube を export する場合、  
**インポート元の鍵に設定されている「expire」と「権限」が上限** として働く。

派生 cube に対して新しく発行する鍵は、  
元鍵より長い expire を持たせることはできない。  
元鍵より広い権限（例えば、元鍵ではread-onlyなのに、新鍵でwrite可にするなど）を与えることはできない。

つまり。

親の鍵が `expire=2026-01-01` かつ `read-only` なら、  
派生 cube の鍵は、最大でも `expire<=2026-01-01` かつ `read-only` までに制限される。

この仕組みにより、**子孫的な派生 cube が、元の所有者が許可していない強い権限や長い期限で勝手に配布されることを防ぐ**。

### 所有者による拡張

もし、より長い有効期限・より大きな権限を持つ鍵を使いたい場合は、  
その cube の本来の所有者に依頼して、新たな鍵を発行してもらう必要がある。
これにより、元 cube の所有者は  
誰にどこまでの権限を渡すか  
どこまで先の期限を許すか  
を常にコントロールできる。

***

## rekey: 鍵の更新

### 概要

`rekey` は、既にインポート済みの cube に紐づく「鍵」を、新たな鍵に差し替えるための操作。

### 典型的な利用シナリオ

usr がある cube を import し、制限された鍵で利用している。  
その後、cube の所有者から、  
より長い expire  
より広い権限  
を持つ新しい鍵が発行される。
利用者は `rekey` エンドポイントを呼び出し、  
古い鍵 → 新しい鍵  
へと差し替える。

### rekey の効果

rekey が成功すると、その cube に対する後続の操作（search / absorb / memify / export など）は、新しい鍵の expire と権限に基づいて評価される。
これにより、**配布済みの cube に後から「アップグレード」を適用できる**。
商用の観点から見ると、  
ベーシックな権限・短い期限の鍵を安価に提供し、  
必要に応じて「上位版鍵」を販売する  
といったライセンスモデルを実現しやすい。

***

## genkey: 鍵の発行

### 概要

`genkey` は、Cube の正当な権利者が新しい鍵を発行する操作。
対象は。

1. 現在所有している Cube。  
2. 過去に **Export した実績のある (Export Recordが存在する)** Cube。

これにより、一度 Export したパッケージに対して、後から何度でも条件を変えて鍵を発行できる。

***

## absorb: 新しい知識の取り込み

### 概要

`absorb` は、外部から与えられた情報やデータを cube に追加し、**知識として蓄積させる** 操作。

### 特徴

absorb によって cube は新しい情報を「覚える」。
ただし、この段階では  
自動的な要約  
構造化  
自己検証  
などは行われず、**単純な知識の追加** に留まる。

結果として。

absorb だけを繰り返しても、cube の知識量は増加するが、  
知識間の関連付け  
高度な推論能力  
説明のわかりやすさ  
といった面の成長は限定的である。

***

## memify: 自己強化と知識の深化

### 概要

`memify` は、cube が **自分自身の内部知識を材料に自問自答を繰り返す** プロセス。
目的は、  
新たな発見・仮説の生成  
知識の再構造化・整理  
説明能力・推論力の向上  
などを通じて、cube の「知性」を強化すること。

### 振る舞い

memify は、cube 内部のデータを読み取り、  
LLM的な推論  
多段階の自己対話  
再書き込み  
などを行うことで、**同じデータ量からより高い回答力を引き出す**。

### absorb との関係

memify の効果は、元となる知識量が多いほど大きくなる。
知識が少ない cube では、自問自答の材料が乏しいため、成長幅も小さい。
absorb によって大量の外部知識を与えた後に memify を実行すると、急速に性能が向上しやすい。

実運用では、  
`absorb` で外部知識を大量投入  
`memify` で自己強化  
という二段構えが、cube を「賢くする」定石パターンとなる。

***

## search: cube への問い合わせ

### 概要

`search` は、usr が特定の cube に対して何でも質問できるエンドポイント。
入力は通常、自然言語のクエリ（質問文）である。

### 特徴

`search` の回答品質は、  
その cube がどれだけ absorb によって知識を取り込んでいるか  
どれだけ memify による自己強化を行ってきたか  
に強く依存する。

成長のイメージとしては。

- create 直後の何も知らない cube → search もほとんど答えられない。  
- 多くの外部知識を absorb し、memify を重ねた cube → 高精度かつ多面的な回答が可能。

また、鍵の権限によっては、search 自体が許可されない、あるいは特定の範囲に制限される可能性もある。

***

## stats / delete: 統計と削除

`stats` は、権限が許可されている場合に、対象 cube に関する統計情報（利用回数やトークン消費など）を参照するためのエンドポイントである。
`delete` は、cube の所有者が自分の所有する cube を削除するためのエンドポイントであり、`allow_delete` フラグは廃止され、所有者は常に削除可能となっている。

***

## operations (absorb, memify, search) とトークン価値

これらの操作は、LLM (Language Model) を使用する。
Cube の市場価値を担保するため、使用されたトークン（Input/Output）は **OpenAI形式で厳密に集計・記録** される。
トークン数の取得に失敗した場合、その操作はエラーとなり完了しない。

***

## cube / 鍵モデルがもたらす新しい価値

### cube は「知識の作品」であり資産

cube は単なるデータファイルではなく、  
吸収された知識  
memify によって練り上げられた内部構造・仮説・説明能力  
を含む、**高度に洗練された「知識の作品」** と考えられる。

優れた cube は、それ自体が「価値ある知識インフラ」として第三者に提供可能な資産になる。

### 鍵＋expire＋権限によるライセンスモデル

export 時に「元の鍵の expire と権限が上限」となる仕組みと、  
rekey による後付けのアップグレード機構が組み合わさることで、  
cube の製作者・所有者は、  
ベースとなる cube を作り、  
その上にさまざまな期間・権限の鍵を発行し、  
それらを利用者に販売・配布する  
というライセンスビジネスを構築できる。

Burn-on-use の鍵と `0=無制限` の回数制限ルールにより、鍵の再利用や不正な延命を防ぎつつ、柔軟な課金・権限設計が可能になる。

### クリエーターと新しいインフラ

この仕組みは、次のような新しいエコシステムを生むインフラになる。

**cube クリエーター**  
特定の分野（法律、医療、プログラミング、教育など）に精通した専門家やチームが、  
知識を absorb し  
memify によって洗練させた高品質な cube を制作する。

**利用者**  
必要な分野の cube を購入またはライセンス契約し、  
鍵を通じて自分の mycute 環境に import し、search を通してその知識を活用する。
場合によっては、自分のデータを absorb してローカルな文脈に合わせて育てる。

**再配布者 / 派生制作者**  
他者が作った cube を import し、自らの手でカスタマイズ・強化しつつ、  
元鍵の expire・権限の範囲内で新たな cube と鍵を生成し、  
二次的な価値をつけてエコシステムに再投入できる。

これらはすべて、  
鍵ごとの expire と権限  
export 時の「元鍵を超えない」上限ルール  
Burn-on-use と回数制限ロジック  
rekey によるアップグレード  
によって厳密にコントロールされるため、  
クリエーターは自分の知識資産を**過剰にコピーされることなく流通させる**ことができ、  
利用者は自分の用途に応じて段階的に権限を広げていくことができる。

***

## まとめ

mycute は、Go 単一バイナリとして動作する「知識システムサーバー」であり、内部で Kuzu ベースのメモリキューブ（cube）を扱う。
cube は暗号化された知識の塊であり、専用の鍵（expire＋権限つき）と Burn-on-use モデル、および回数制限ロジックによって制御される。

create/import/export/rekey/genkey によって、  
誰が  
どの cube を  
どの範囲・期間・回数で  
使えるかを精密に管理する。

absorb/memify/search/stats によって、  
知識の追加  
自己強化  
実際の利用（質問応答）  
価値計測（トークン集計）  
を行う。

export 時の上限ルールと Burn-on-use 鍵、`0=無制限` の詳細な権限管理、そして rekey/genkey によるアップグレード機構により、  
cube 自体が「販売可能な知識資産」となり、  
cube のクリエーターや所有者が鍵発行を通じてビジネスを成立させられるインフラになっている。
